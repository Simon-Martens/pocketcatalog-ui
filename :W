import type { Group, Schema, Table, ViewGroup, ViewGroupResult } from "$lib/newtypes";
import { type RecordModel } from "pocketbase";

import { api } from "./pocketbase";

// This is all the Meta Groups, into which fields can be grouped
export const ViewGroups: ViewGroup[] = [
    {
        "Name": "Symbol",
        "friendlyName": "None",
        "Groups": ["Template", "State", "Symbol"],
        "NeverGroup": true
    },
    {
        "Name": "Norm Data",
        "friendlyName": "Normdaten",
        "Groups": ["Name", "Works", "Serials", "Issue", "Date", "Agents", "Places"],
    },
    {
        "Name": "Count Data",
        "friendlyName": "ZÃ¤hlung",
        "Groups": ["Order", "Count"],
        "NeverGroup": true,
    },
    {
        "Name": "Title Data",
        "friendlyName": "Titel- & Transkriptionsdaten",
        "Groups": ["Title", "Transcriptions"],
    },
    {
        "Name": "None",
        "Groups": ["None"],
        "NeverGroup": true
    },
    {
        "Name": "Media Data",
        "friendlyName": "Medium & Format",
        "Groups": ["Extend", "MediaSpecific", "MediaMeta"]
    },
    {
        "Name": "Annotations",
        "friendlyName": "Anmerkungen",
        "Groups": ["Annotations"]
    },
    {
        "Name": "Editor Data",
        "friendlyName": "Forschungsdaten",
        "Groups": ["Identifier", "Research", "Description", "Collections", "Tag", "EditorNotes"]
    },
    {
        "Name": "Rest",
        "Groups": ["URL", "File", "Deprecated"],
        "NeverGroup": true
    },
    {
        "Name": "Parent Child Relations",
        "Groups": ["Children", "Entries", "Relation"],
    }
];



export class RecordsList {
    List = $state<null | RecordModel[]>(null)
    TotalItems = $state(0);
    TotalPages = $state(0);

    Loading = $state(false);
    Refreshing = $state(false);

    Page = $state(1);
    Sort = $state<string[]>([]);
    Filter: string = $state("");

    // We give out the grouping for the visible groups once here, so we don't have
    // to iterate over all fields or the visible array for every single table cell.
    Visible = $state<string[]>([]);
    Grouped = $state<string[]>(["Title Data"]);
    VisibleGroups = $derived.by(() => {
        let vg: Record<number, { [FieldType in Group]: Schema[] }> = {}
        let i = 0;
        for (let mg of this.YieldGroups()) {
            if (mg.Showable) {
                for (const [k, v] of Object.entries(mg.Showable)) {
                    for (const f of v) {
                        if (this.Visible.indexOf(f.Name) !== -1) {
                            if (!Object.hasOwn(vg, i)) {
                                //@ts-ignore surely it's fine nothing can ever go wrong here
                                vg[i] = {};
                            }
                            if (!Object.hasOwn(vg[i], k)) {
                                vg[i][k as Group] = [];
                            }
                            vg[i][k as Group].push(f);
                        }
                    }
                }
            }
            i++;
        }
        console.log(vg);
        return vg;
    });

    Selected = $state([]);
    Selectable = $state<boolean>(false);

    #expand: string;
    #scheme: Table;
    #perpage: number;
    #permanentFilter: string = "";

    constructor(scheme: Table, perPage: number = 120, listFilter: boolean = true) {
        console.log("constructed with:");
        console.log(scheme);
        this.#scheme = scheme;
        this.#perpage = perPage;
        this.#expand = this.#Expand();

        this.DefaultSort();
        this.DefaultFilter();
        this.DefaultVisible();

        if (scheme.ListFilter && listFilter) {
            this.#permanentFilter = scheme.ListFilter
        }

    }

    DefaultSort() {
        this.Sort = [];

        if (this.#scheme.DefaultSort) {
            this.Sort = this.#scheme.DefaultSort;
            return;
        }

        if (this.#scheme.Fields && this.#scheme.Fields.Main) {
            for (const f of this.#scheme.Fields.Main)
                this.Sort.push(f.Name);
        }

        if (this.#scheme.Fields && this.#scheme.Fields.Diff) {
            for (const f of this.#scheme.Fields.Diff)
                this.Sort.push(f.Name)
        }
    }

    DefaultFilter() {
        this.Filter = '';
        if (this.#scheme.DefaultFilter)
            this.Filter = this.#scheme.DefaultFilter
    }

    DefaultVisible() {
        let vis = [];
        if (!this.#scheme.Fields) return;
        for (const v of Object.values(this.#scheme.Fields)) {
            for (const f of v)
                if (!Object.hasOwn(f, "TVisibility") || f.TVisibility)
                    vis.push(f.Name);
        }
        this.Visible = vis;
    }

    // System & Some other Fields are not yielded here
    // TODO: Do not modify the const!
    * YieldGroups(): Generator<ViewGroupResult> {
        if (!this.#scheme.Fields) return;
        let i = 0;
        for (const mg of ViewGroups) {
            let ret: ViewGroupResult = null;
            for (const mgg of mg.Groups) {
                let show = [];
                if (Object.hasOwn(this.#scheme.Fields, mgg)) {
                    for (const f of this.#scheme.Fields[mgg]) {
                        if (!f.THidden)
                            show.push(f);
                    }
                }
                if (show.length) {
                    if (!ret) ret = {
                        Group: i,
                        Fields: []
                    };
                    ret[mgg as Group] = show;
                }
            }
            i++;
            if (ret) yield;
        }
    }

    SortBy(name: string) {
        const i = this.Sort.indexOf(name);
        const j = this.Sort.indexOf('-' + name);
        if (i !== -1) {
            this.Sort = [this.#InvertSort(this.Sort[i])];
        } else if (j !== -1) {
            this.Sort = [this.#InvertSort(this.Sort[j])];
        } else {
            this.Sort = [name];
        }
    }

    AndSortBy(name: string) {
        const i = this.Sort.indexOf(name);
        const j = this.Sort.indexOf('-' + name);
        if (i !== -1) {
            this.Sort.splice(i, 1, this.#InvertSort(this.Sort[i]))
        } else if (j !== -1) {
            this.Sort.splice(j, 1, this.#InvertSort(this.Sort[j]))
        } else {
            this.Sort.push(name)
        }
    }

    #InvertSort(name: string) {
        if (name.startsWith('-')) {
            return name.substring(1, name.length);
        } else {
            return '-' + name;
        }
    }

    async Next() {
        this.Page = this.Page + 1;
        return this.Fetch();
    }

    // TODO: refresh resets page to one and does not reload all the pages
    async Refresh() {
        this.List = [];
        this.Page = 1;
        this.Refreshing = true;
        return this.#InternalFetch(this.#perpage, this.Page, this.Filter, this.Sort)
            .then(() => this.Refreshing = false);
    }

    async Fetch() {
        this.Loading = true;
        return this.#InternalFetch(this.#perpage, this.Page, this.Filter, this.Sort)
            .then(() => this.Loading = false);
    }

    async #InternalFetch(perpage: number, page: number, filter: string, sort: string[]) {
        const s = sort.join(",");
        let f = this.#permanentFilter;

        if (filter) {
            if (f) f = f + " && ";
            f = f + filter;
        }

        return api.collection(this.#scheme.Name)
            .getList(page, perpage, {
                filter: f,
                sort: s,
                skipTotal: page !== 1,
                expand: this.#expand,
                requestKey: null,
            })
            .catch((err) => { console.log(err); throw err; })
            .then((res) => {
                if (page === 1) {
                    if (!res) {
                        this.List = null;
                        this.TotalItems = 0;
                        this.TotalPages = 0;
                    } else {
                        this.List = res.items;
                        this.TotalItems = res.totalItems;
                        this.TotalPages = res.totalPages;
                    }
                } else {
                    if (res) {
                        if (this.List) {
                            this.List.push(...res.items);
                        } else {
                            this.List = res.items;
                        }
                    }
                }
            })
    }

    #Expand() {
        if (!this.#scheme || !this.#scheme.Fields) return "";
        let exp = "";
        for (const [_, g] of Object.entries(this.#scheme.Fields)) {
            for (const f of g) {
                if (f.THidden) continue;
                if (f.Type.startsWith("Relation")) {
                    if (exp !== "") exp = exp + ",";
                    if (f.Options && f.Options.Expand) {
                        exp = exp + f.Options.Expand;
                    } else {
                        exp = exp + f.Name;
                    }
                } else if (f.Type.startsWith("BackRelation") && f.Options) {
                    if (f.Options.Expand) {
                        if (exp !== "") exp = exp + ",";
                        exp = exp + f.Options.Expand;
                    } else if (f.Options.Field)
                        for (const ef of f.Options.Field) {
                            if (exp !== "") exp = exp + ",";
                            exp = exp + f.Options.Table + "_via_" + ef;
                        }
                }
            }
        }
        return exp;
    }
}
